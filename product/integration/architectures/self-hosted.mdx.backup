---
title: "Self-Hosted Architecture"
description: "Deploy Forest Admin agent in your infrastructure while Forest Admin hosts the UI - the most popular deployment option"
---

The self-hosted architecture gives you full control over your data and code by hosting the Forest Admin agent in your own infrastructure. This is the **most popular deployment option** for production applications.

## Architecture Overview

```
┌─────────┐      ┌──────────────────┐      ┌─────────────┐      ┌──────────┐
│ Browser │ ───> │ Forest Admin UI  │ ───> │ Your Agent  │ ───> │   Your   │
│         │      │ (Forest Admin)   │      │    (Your    │      │ Database │
└─────────┘      └──────────────────┘      │ Infrastructure) │   └──────────┘
                                            └─────────────┘
```

### How it Works

1. **Your users** access the Forest Admin UI hosted at `app.forestadmin.com`
2. **Forest Admin UI** makes API calls to your agent
3. **Your agent** runs in your infrastructure (AWS, GCP, Heroku, etc.)
4. **Your agent** queries your database directly
5. **All data** stays within your infrastructure

<Info>
**Key benefit**: Your data never leaves your infrastructure. Only metadata about your schema is sent to Forest Admin's UI.
</Info>

## Components

### Your Agent

The agent is a Node.js, Ruby, or Python application that you deploy and maintain:

- Runs in your infrastructure
- Has direct access to your database
- Executes all business logic (Smart Actions, Fields, Hooks)
- Handles authentication and authorization
- Exposes a REST API for the Forest Admin UI

### Forest Admin UI

The UI is hosted and maintained by Forest Admin:

- Accessible at `app.forestadmin.com`
- Provides the admin interface for your users
- Communicates with your agent via HTTPS
- Receives only schema metadata, not your actual data
- Managed and updated by Forest Admin

### Your Database

Your existing database remains unchanged:

- PostgreSQL, MySQL, MongoDB, or other supported databases
- Stays in your infrastructure
- Only accessible to your agent
- No direct connection from Forest Admin

## Agent deployment

You can deploy the Forest Admin agent in two ways, depending on your application architecture:

### In-app deployment

The agent runs **inside your existing application** as part of the same process:

**How it works:**
- Agent code is integrated into your application codebase
- Shares the same Node.js/Ruby/Python process as your app
- Uses the same database connection pool
- Deployed together with your application

**Best for:**
- Applications with a single backend service
- Monolithic architectures
- Simplified deployment and maintenance
- Sharing database connections and ORM models

**Example (Node.js with Express):**
```javascript
const express = require('express');
const { createAgent } = require('@forestadmin/agent');
const { createSqlDataSource } = require('@forestadmin/datasource-sql');

const app = express();

// Your existing application routes
app.get('/api/users', (req, res) => { /* ... */ });

// Forest Admin agent integrated in the same app
const agent = createAgent({
  authSecret: process.env.FOREST_AUTH_SECRET,
  envSecret: process.env.FOREST_ENV_SECRET,
  isProduction: true,
});

agent.addDataSource(createSqlDataSource(process.env.DATABASE_URL));

// Mount Forest Admin on a subpath
agent.mountOnExpress(app).start();

// Your app and Forest Admin share the same port
app.listen(3000);
```

### Standalone deployment

The agent runs as a **separate, dedicated service**:

**How it works:**
- Agent runs in its own process/container
- Independent deployment and scaling
- Dedicated resources for Forest Admin
- Separate database connection pool

**Best for:**
- Microservices architectures
- Multiple applications accessing the same database
- Independent scaling of admin panel
- Isolation of admin functionality

**Example (Node.js standalone):**
```javascript
const { createAgent } = require('@forestadmin/agent');
const { createSqlDataSource } = require('@forestadmin/datasource-sql');

// Dedicated Forest Admin service
const agent = createAgent({
  authSecret: process.env.FOREST_AUTH_SECRET,
  envSecret: process.env.FOREST_ENV_SECRET,
  isProduction: true,
});

agent.addDataSource(createSqlDataSource(process.env.DATABASE_URL));

// Standalone service on its own port
agent.start();
```

**Architecture comparison:**

| Aspect | In-app | Standalone |
|--------|--------|------------|
| **Deployment** | Single deployment | Separate deployment |
| **Process** | Shared with your app | Dedicated process |
| **Port** | Same port as your app | Own port (e.g., 3310) |
| **Database connections** | Shared pool | Dedicated pool |
| **Scaling** | Scales with your app | Scales independently |
| **Resources** | Shared CPU/memory | Dedicated CPU/memory |
| **Isolation** | Low isolation | High isolation |
| **Complexity** | Simpler | More complex |

<Info>
**Recommendation**: Start with **in-app deployment** for simplicity. Move to **standalone** if you need independent scaling or have a microservices architecture.
</Info>

## Privacy by design

The self-hosted architecture is built with privacy as a core principle:

```
┌──────────────────────────────────────────────────────────────┐
│                     YOUR INFRASTRUCTURE                       │
│                                                               │
│  ┌─────────────┐                    ┌──────────────┐        │
│  │   Your DB   │ ◄─── SQL/NoSQL ─── │  Your Agent  │        │
│  │             │                     │              │        │
│  │  Customer   │                     │  • Queries   │        │
│  │  Orders     │                     │  • Business  │        │
│  │  Invoices   │                     │    logic     │        │
│  │  PII data   │                     │  • Custom    │        │
│  └─────────────┘                     │    code      │        │
│                                      └───────┬──────┘        │
│                                              │               │
│                                              │ HTTPS         │
└──────────────────────────────────────────────┼───────────────┘
                                               │
                                        Only schema
                                        metadata sent
                                        (no actual data)
                                               │
                                               ▼
                            ┌──────────────────────────────┐
                            │   FOREST ADMIN SERVERS       │
                            │                              │
                            │  • UI rendering              │
                            │  • Schema storage            │
                            │  • User authentication       │
                            │                              │
                            │  NO access to your data      │
                            └──────────────────────────────┘
```

**What stays in your infrastructure:**
- ✅ All your data (customer records, PII, financial data)
- ✅ Database queries and results
- ✅ Business logic execution
- ✅ Smart Actions code
- ✅ API calls to internal services

**What Forest Admin receives:**
- Schema metadata only (table names, column types, relationships)
- No actual data from your database
- No query results
- No customer information

## Benefits

### Full Control Over Data

Your data never leaves your infrastructure:

- Database queries execute in your network
- No data is sent to Forest Admin servers
- Meet data sovereignty requirements
- Comply with GDPR, SOC2, and other regulations

### Unlimited Customization

Full access to the agent's codebase:

- Write custom Smart Actions with any logic
- Create computed Smart Fields
- Add hooks for complex workflows
- Use any npm/gem/pip package
- Integrate with internal services

<Tabs>
  <Tab title="Node.js">
    ```javascript
    // Full customization with Smart Actions
    agent.customizeCollection('orders', collection => {
      collection.addAction('Process Refund', {
        scope: 'Single',
        execute: async (context, resultBuilder) => {
          const order = await context.getRecord(['id', 'amount']);

          // Call your internal payment service
          await paymentService.processRefund(order.id, order.amount);

          // Update your database
          await database.orders.update(order.id, { status: 'refunded' });

          // Send notification
          await emailService.sendRefundConfirmation(order.customer_email);

          return resultBuilder.success('Refund processed successfully!');
        }
      });
    });
    ```
  </Tab>
  <Tab title="Ruby">
    ```ruby
    # Full customization with Smart Actions
    Forest::Collection.customize(:orders) do
      action 'Process Refund', type: :single do |context|
        order = context.record

        # Call your internal payment service
        PaymentService.process_refund(order.id, order.amount)

        # Update your database
        Order.update(order.id, status: 'refunded')

        # Send notification
        EmailService.send_refund_confirmation(order.customer_email)

        context.success('Refund processed successfully!')
      end
    end
    ```
  </Tab>
</Tabs>

### Better Performance

Direct database access provides optimal performance:

- No network hops through Forest Admin servers
- Query optimization under your control
- Use database replicas for read operations
- Scale horizontally as needed

### Production-Ready Security

Full control over security configuration:

- Your authentication mechanism
- Your network security rules
- Your database access controls
- Your encryption standards
- Your audit logging

## Requirements

### Infrastructure

You need a server or container to host the agent:

- **Cloud providers**: AWS (EC2, ECS, Lambda), GCP (Compute Engine, Cloud Run), Azure
- **Platform-as-a-Service**: Heroku, Render, Railway, Fly.io
- **Container orchestration**: Kubernetes, Docker Swarm
- **Traditional hosting**: VPS, dedicated servers

### Runtime Environment

Depending on your chosen agent:

- **Node.js agent**: Node.js 14+ (18+ recommended)
- **Ruby agent**: Ruby 2.7+ (3.0+ recommended)
- **Python agent**: Python 3.8+ (3.10+ recommended)

### Database Access

Your agent needs to connect to your database:

- Direct connection string
- Network access (can be internal)
- Read/write permissions (read-only for sensitive use cases)
- Connection pooling support

### Internet Access

Your agent needs outbound HTTPS access to:

- `api.forestadmin.com` - For authentication and schema updates
- `app.forestadmin.com` - For UI communication

<Info>
Only outbound connections are required. Your agent doesn't need to be publicly accessible.
</Info>

## Troubleshooting

### Cloud Providers

<Tabs>
  <Tab title="AWS">
    Deploy on AWS using multiple services:

    **Elastic Beanstalk** (easiest):
    ```bash
    # Initialize Elastic Beanstalk
    eb init -p node.js-18 forest-admin-agent

    # Create environment
    eb create production

    # Set environment variables
    eb setenv FOREST_ENV_SECRET=xxx DATABASE_URL=xxx

    # Deploy
    eb deploy
    ```

    **ECS/Fargate** (containers):
    ```dockerfile
    FROM node:18-alpine
    WORKDIR /app
    COPY package*.json ./
    RUN npm ci --only=production
    COPY . .
    CMD ["node", "index.js"]
    ```

    **Lambda** (serverless):
    Use the Forest Admin Lambda adapter for serverless deployment.
  </Tab>
  <Tab title="Heroku">
    Deploy to Heroku in minutes:

    ```bash
    # Create Heroku app
    heroku create my-forest-admin-agent

    # Add PostgreSQL if needed
    heroku addons:create heroku-postgresql:mini

    # Set environment variables
    heroku config:set FOREST_ENV_SECRET=xxx

    # Deploy
    git push heroku main

    # Scale
    heroku ps:scale web=1
    ```

    **Procfile**:
    ```
    web: node index.js
    ```
  </Tab>
  <Tab title="Docker">
    Use Docker for consistent deployments:

    **Dockerfile**:
    ```dockerfile
    FROM node:18-alpine

    WORKDIR /app

    # Install dependencies
    COPY package*.json ./
    RUN npm ci --only=production

    # Copy application
    COPY . .

    # Expose port
    EXPOSE 3000

    # Start application
    CMD ["node", "index.js"]
    ```

    **docker-compose.yml**:
    ```yaml
    version: '3.8'
    services:
      agent:
        build: .
        ports:
          - "3000:3000"
        environment:
          - FOREST_ENV_SECRET=${FOREST_ENV_SECRET}
          - DATABASE_URL=${DATABASE_URL}
        restart: unless-stopped
    ```

    Deploy:
    ```bash
    docker-compose up -d
    ```
  </Tab>
</Tabs>

### Kubernetes

Deploy at scale with Kubernetes:

**deployment.yaml**:
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: forest-admin-agent
spec:
  replicas: 3
  selector:
    matchLabels:
      app: forest-admin-agent
  template:
    metadata:
      labels:
        app: forest-admin-agent
    spec:
      containers:
      - name: agent
        image: your-registry/forest-admin-agent:latest
        ports:
        - containerPort: 3000
        env:
        - name: FOREST_ENV_SECRET
          valueFrom:
            secretKeyRef:
              name: forest-admin-secrets
              key: env-secret
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: forest-admin-secrets
              key: database-url
        resources:
          requests:
            memory: "256Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "500m"
```

## Security Considerations

### Network Security

Configure your network to allow only necessary traffic:

```
Inbound:
  - Port 443 (HTTPS) from Forest Admin UI only (optional, for private networks)
  - Or no inbound if using reverse proxy

Outbound:
  - api.forestadmin.com (HTTPS)
  - app.forestadmin.com (HTTPS)
  - Your database
```

### Authentication

Forest Admin uses environment secrets for authentication:

```bash
# Your unique environment secret
FOREST_ENV_SECRET=xxx
```

<Warning>
Never commit your `FOREST_ENV_SECRET` to version control. Use environment variables or secret management tools.
</Warning>

### Database Credentials

Follow least privilege principle:

```sql
-- Create read-only user for viewing data
CREATE USER forest_readonly WITH PASSWORD 'xxx';
GRANT CONNECT ON DATABASE mydb TO forest_readonly;
GRANT USAGE ON SCHEMA public TO forest_readonly;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO forest_readonly;

-- Or create read-write user for full operations
CREATE USER forest_admin WITH PASSWORD 'xxx';
GRANT ALL PRIVILEGES ON DATABASE mydb TO forest_admin;
```

### HTTPS Enforcement

Always use HTTPS for agent communication:

```javascript
// Node.js agent
const agent = createAgent({
  authSecret: process.env.FOREST_AUTH_SECRET,
  envSecret: process.env.FOREST_ENV_SECRET,
  isProduction: process.env.NODE_ENV === 'production',
  // Enforce HTTPS
  schemaPath: './forest'
});

// In production, use HTTPS
if (process.env.NODE_ENV === 'production') {
  agent.mountOnStandaloneServer(Number(process.env.PORT), 'https');
}
```

## Scaling

### Horizontal Scaling

Run multiple agent instances behind a load balancer:

```
           ┌─ Agent Instance 1 ─┐
           │                    │
Load       ├─ Agent Instance 2 ─┤ ──> Database
Balancer ─>│                    │
           ├─ Agent Instance 3 ─┤
           │                    │
           └─ Agent Instance N ─┘
```

Each instance can handle requests independently.

### Database Optimization

Use read replicas for better performance:

<Tabs>
  <Tab title="Node.js">
    ```javascript
    const { createSqlDataSource } = require('@forestadmin/datasource-sql');

    agent.addDataSource(createSqlDataSource({
      uri: process.env.DATABASE_URL,
      // Read from replica
      replication: {
        read: [{ host: 'replica1.example.com' }, { host: 'replica2.example.com' }],
        write: { host: 'primary.example.com' }
      }
    }));
    ```
  </Tab>
  <Tab title="Ruby">
    ```ruby
    # Configure read replicas in database.yml
    production:
      primary:
        url: <%= ENV['DATABASE_URL'] %>
      replica:
        url: <%= ENV['READ_REPLICA_URL'] %>
        replica: true
    ```
  </Tab>
</Tabs>

### Connection Pooling

Configure connection pools for optimal resource usage:

```javascript
agent.addDataSource(createSqlDataSource({
  uri: process.env.DATABASE_URL,
  pool: {
    max: 20,        // Maximum connections
    min: 5,         // Minimum connections
    idle: 10000,    // Close idle connections after 10s
    acquire: 30000, // Max time to acquire connection
  }
}));
```

## Monitoring and Maintenance

### Health Checks

Implement health check endpoints:

```javascript
// Node.js Express example
app.get('/health', (req, res) => {
  res.status(200).json({
    status: 'healthy',
    timestamp: new Date().toISOString()
  });
});

// Check database connectivity
app.get('/health/database', async (req, res) => {
  try {
    await database.raw('SELECT 1');
    res.status(200).json({ database: 'connected' });
  } catch (error) {
    res.status(503).json({ database: 'disconnected', error: error.message });
  }
});
```

### Logging

Configure structured logging:

```javascript
const agent = createAgent({
  // ...
  loggerLevel: 'info', // 'debug', 'info', 'warn', 'error'
});

// Custom logger
agent.use((req, res, next) => {
  console.log({
    timestamp: new Date().toISOString(),
    method: req.method,
    path: req.path,
    userId: req.user?.id
  });
  next();
});
```

### Updates

Keep your agent up to date:

```bash
# Check for updates
npm outdated @forestadmin/agent

# Update to latest
npm update @forestadmin/agent

# Or update all Forest Admin packages
npm update @forestadmin/*
```

<Info>
Forest Admin releases updates regularly with bug fixes and new features. Subscribe to [release notes](https://www.forestadmin.com/releases) to stay informed.
</Info>

## Troubleshooting

### Agent Can't Connect to Forest Admin UI

**Symptoms**: Agent starts but UI shows "Agent not responding"

**Solutions**:
1. Check outbound HTTPS access to `api.forestadmin.com`
2. Verify `FOREST_ENV_SECRET` is correct
3. Check firewall rules allow outbound connections
4. Ensure agent is running and accessible

```bash
# Test connectivity
curl https://api.forestadmin.com/health

# Check agent logs
heroku logs --tail  # Heroku
kubectl logs -f deployment/forest-admin-agent  # Kubernetes
```

### Database Connection Errors

**Symptoms**: "Connection refused" or timeout errors

**Solutions**:
1. Verify `DATABASE_URL` is correct
2. Check database accepts connections from agent's IP
3. Test connection from agent server:

```bash
# PostgreSQL
psql "postgresql://user:password@host:5432/database"

# MySQL
mysql -h host -u user -p database
```

### Performance Issues

**Symptoms**: Slow queries or timeouts

**Solutions**:
1. Add database indexes on frequently queried columns
2. Enable connection pooling
3. Use read replicas for read-heavy operations
4. Scale horizontally with multiple agent instances

```sql
-- Add index example
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_orders_created_at ON orders(created_at);
```

## What's Next?

Now that you understand self-hosted architecture:

<CardGroup cols={2}>
  <Card title="Setup Guide" icon="rocket" href="/get-started/quickstart-self-hosted">
    Step-by-step guide to deploy your agent
  </Card>
  <Card title="Environment Variables" icon="key" href="/product/integration/environment-variables">
    Configure your agent with environment variables
  </Card>
  <Card title="Data Sources" icon="database" href="/product/integration/data-sources/overview">
    Connect to SQL, MongoDB, or custom sources
  </Card>
  <Card title="Smart Actions" icon="bolt" href="/product/process/actions/overview">
    Add custom business logic to your agent
  </Card>
</CardGroup>
