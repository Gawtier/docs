---
title: Forms
description: Collect user input with static and dynamic action forms
---

Action forms let you collect user input before executing an action. Forms can be static with fixed fields, or dynamic with fields that adapt based on context or user input.

## Field properties

Fields are configurable using the following properties:

| Property | Required | Type | Description |
|----------|----------|------|-------------|
| **type** | Yes | string | Field type: `Boolean`, `Date`, `Dateonly`, `Enum`, `Json`, `Number`, `NumberList`, `EnumList`, `String`, `StringList`, `File`, `FileList`, `Collection` |
| **label** | Yes | string | Label displayed to the user |
| **id** | No | string | Internal identifier. If not set, the label is used. Use this to access values in `context.formValues` |
| **description** | No | string | Help text displayed below the field |
| **isRequired** | No | boolean | Make the field required (default: false) |
| **defaultValue** | No | any | Default value pre-filled in the form |
| **isReadOnly** | No | boolean | Make the field read-only (default: false) |
| **enumValues** | Required for `Enum` | string[] | List of possible values when type is `Enum` |
| **widget** | No | string | UI widget to use (see widgets section below) |

## Basic form example

<CodeGroup>
```javascript Node.js / Cloud
agent.customizeCollection('customers', collection => {
  collection.addAction('Charge credit card', {
    scope: 'Single',
    form: [
      {
        type: 'Number',
        label: 'Amount',
        description: 'Amount in USD (e.g., 42.50)',
        isRequired: true,
      },
      {
        type: 'String',
        label: 'Description',
        widget: 'TextArea',
      },
    ],
    execute: async (context, resultBuilder) => {
      const { Amount, Description } = context.formValues;
      const customer = await context.getRecord(['stripeId']);

      // Charge the credit card
      await stripe.charges.create({
        amount: Amount * 100,
        currency: 'usd',
        customer: customer.stripeId,
        description: Description,
      });

      return resultBuilder.success('Charged successfully!');
    },
  });
});
```

```ruby Ruby
forest_agent.customize_collection('customers') do |collection|
  collection.add_action(
    'Charge credit card',
    BaseAction.new(
      scope: ActionScope::SINGLE,
      form: [
        {
          type: FieldType::NUMBER,
          label: 'Amount',
          description: 'Amount in USD (e.g., 42.50)',
          is_required: true
        },
        {
          type: FieldType::STRING,
          label: 'Description',
          widget: 'TextArea'
        }
      ]
    ) do |context, result_builder|
      form_values = context.form_values
      customer = context.get_record(['stripeId'])

      # Charge the credit card
      # ...

      result_builder.success('Charged successfully!')
    end
  )
end
```
</CodeGroup>

## Field types

### String

Text input for short strings.

```javascript
{ type: 'String', label: 'Name' }
```

Use the `TextArea` widget for longer text:

```javascript
{ type: 'String', label: 'Description', widget: 'TextArea' }
```

### Number

Numeric input with optional constraints.

```javascript
{ type: 'Number', label: 'Amount', defaultValue: 0 }
```

### Boolean

Checkbox for true/false values.

```javascript
{ type: 'Boolean', label: 'Send confirmation email' }
```

### Date and Dateonly

Date picker for dates with or without time.

```javascript
{ type: 'Date', label: 'Delivery date and time' }
{ type: 'Dateonly', label: 'Birth date' }
```

### Enum

Dropdown with predefined options.

```javascript
{
  type: 'Enum',
  label: 'Status',
  enumValues: ['pending', 'approved', 'rejected'],
  isRequired: true
}
```

### Collection

Reference to a record from another collection.

```javascript
{
  type: 'Collection',
  label: 'Assignee',
  collectionName: 'users',
  description: 'Select the user to assign this ticket to'
}
```

The value will be the primary key of the selected record (as an array for composite keys).

### File and FileList

File upload fields.

```javascript
{ type: 'File', label: 'Upload document' }
{ type: 'FileList', label: 'Upload attachments' }
```

### Lists

Arrays of values.

```javascript
{ type: 'StringList', label: 'Tags' }
{ type: 'NumberList', label: 'Scores' }
{ type: 'EnumList', label: 'Categories', enumValues: ['A', 'B', 'C'] }
```

## Dynamic forms

Make forms reactive by using functions instead of static values. Functions receive the action context and can access form values and selected records.

### Dynamic required fields

Make a field required based on another field's value:

<CodeGroup>
```javascript Node.js / Cloud
form: [
  {
    type: 'Number',
    label: 'Amount',
    isRequired: true,
  },
  {
    type: 'String',
    label: 'Justification',
    description: 'Required for amounts over $1000',
    // Only required if amount > 1000
    isRequired: context => context.formValues.Amount > 1000,
  },
]
```

```ruby Ruby
form: [
  {
    type: FieldType::NUMBER,
    label: 'Amount',
    is_required: true
  },
  {
    type: FieldType::STRING,
    label: 'Justification',
    description: 'Required for amounts over $1000',
    # Only required if amount > 1000
    is_required: ->(context) { context.form_values['Amount'] > 1000 }
  }
]
```
</CodeGroup>

### Conditional visibility

Show or hide fields based on conditions:

<CodeGroup>
```javascript Node.js / Cloud
form: [
  {
    type: 'Boolean',
    label: 'Send email notification',
    id: 'sendEmail',
  },
  {
    type: 'String',
    label: 'Email address',
    // Only show if sendEmail is checked
    if: context => context.formValues.sendEmail === true,
  },
]
```

```ruby Ruby
form: [
  {
    type: FieldType::BOOLEAN,
    label: 'Send email notification',
    id: 'sendEmail'
  },
  {
    type: FieldType::STRING,
    label: 'Email address',
    # Only show if sendEmail is checked
    if: ->(context) { context.form_values['sendEmail'] == true }
  }
]
```
</CodeGroup>

### Default values from record data

Pre-fill form with data from the selected record:

<CodeGroup>
```javascript Node.js / Cloud
form: [
  {
    type: 'Number',
    label: 'Refund amount',
    // Default to the order total
    defaultValue: async context => {
      const order = await context.getRecord(['total']);
      return order.total;
    },
  },
]
```

```ruby Ruby
form: [
  {
    type: FieldType::NUMBER,
    label: 'Refund amount',
    # Default to the order total
    default_value: ->(context) {
      order = context.get_record(['total'])
      order['total']
    }
  }
]
```
</CodeGroup>

### Dynamic enum values

Change dropdown options based on context:

<CodeGroup>
```javascript Node.js / Cloud
form: [
  {
    type: 'Enum',
    label: 'Department',
    id: 'department',
    enumValues: ['Engineering', 'Sales', 'Support'],
  },
  {
    type: 'Enum',
    label: 'Team',
    // Teams depend on selected department
    enumValues: context => {
      const dept = context.formValues.department;
      if (dept === 'Engineering') return ['Backend', 'Frontend', 'DevOps'];
      if (dept === 'Sales') return ['Inbound', 'Outbound'];
      if (dept === 'Support') return ['L1', 'L2', 'L3'];
      return [];
    },
  },
]
```

```ruby Ruby
form: [
  {
    type: FieldType::ENUM,
    label: 'Department',
    id: 'department',
    enum_values: ['Engineering', 'Sales', 'Support']
  },
  {
    type: FieldType::ENUM,
    label: 'Team',
    # Teams depend on selected department
    enum_values: ->(context) {
      dept = context.form_values['department']
      if dept == 'Engineering'
        ['Backend', 'Frontend', 'DevOps']
      elsif dept == 'Sales'
        ['Inbound', 'Outbound']
      elsif dept == 'Support'
        ['L1', 'L2', 'L3']
      else
        []
      end
    }
  }
]
```
</CodeGroup>

### Dynamic collection references

Change the target collection dynamically:

<CodeGroup>
```javascript Node.js / Cloud
form: [
  {
    type: 'Enum',
    label: 'Entity type',
    id: 'entityType',
    enumValues: ['user', 'company'],
  },
  {
    type: 'Collection',
    label: 'Entity',
    // Collection name depends on entity type
    collectionName: context => context.formValues.entityType,
  },
]
```

```ruby Ruby
form: [
  {
    type: FieldType::ENUM,
    label: 'Entity type',
    id: 'entityType',
    enum_values: ['user', 'company']
  },
  {
    type: FieldType::COLLECTION,
    label: 'Entity',
    # Collection name depends on entity type
    collection_name: ->(context) { context.form_values['entityType'] }
  }
]
```
</CodeGroup>

## Widgets

Widgets customize the UI appearance of fields. Here are the most common ones:

### TextArea

Multi-line text input.

```javascript
{ type: 'String', label: 'Notes', widget: 'TextArea' }
```

### Dropdown

Alternative to Enum for dropdown selection.

```javascript
{
  type: 'String',
  label: 'Priority',
  widget: 'Dropdown',
  options: ['Low', 'Medium', 'High']
}
```

### RadioGroup

Radio buttons for single selection.

```javascript
{
  type: 'Enum',
  label: 'Plan',
  widget: 'RadioGroup',
  enumValues: ['Free', 'Pro', 'Enterprise']
}
```

### CheckboxGroup

Checkboxes for multiple selection.

```javascript
{
  type: 'EnumList',
  label: 'Features',
  widget: 'CheckboxGroup',
  enumValues: ['API Access', 'Priority Support', 'Custom Domain']
}
```

### DatePicker

Calendar widget for date selection.

```javascript
{ type: 'Date', label: 'Appointment', widget: 'DatePicker' }
```

### ColorPicker

Color selection widget.

```javascript
{ type: 'String', label: 'Brand color', widget: 'ColorPicker' }
```

### FilePicker

File upload with preview.

```javascript
{ type: 'File', label: 'Profile picture', widget: 'FilePicker' }
```

### JsonEditor

JSON editor with syntax highlighting.

```javascript
{ type: 'Json', label: 'Configuration', widget: 'JsonEditor' }
```

### UserDropdown

Dropdown pre-filled with Forest Admin users.

```javascript
{ type: 'String', label: 'Assigned to', widget: 'UserDropdown' }
```

### CurrencyInput

Number input with currency formatting.

```javascript
{
  type: 'Number',
  label: 'Price',
  widget: 'CurrencyInput',
  options: { currency: 'USD' }
}
```

### RichText

Rich text editor with formatting options.

```javascript
{ type: 'String', label: 'Content', widget: 'RichText' }
```

## Advanced patterns

### Multi-step forms

Create wizard-like forms by conditionally showing sections:

<CodeGroup>
```javascript Node.js / Cloud
form: [
  {
    type: 'Enum',
    label: 'Action type',
    id: 'actionType',
    enumValues: ['refund', 'replace', 'credit'],
  },
  // Refund fields
  {
    type: 'Number',
    label: 'Refund amount',
    if: context => context.formValues.actionType === 'refund',
  },
  // Replacement fields
  {
    type: 'Collection',
    label: 'Replacement product',
    collectionName: 'products',
    if: context => context.formValues.actionType === 'replace',
  },
  // Store credit fields
  {
    type: 'Number',
    label: 'Credit amount',
    if: context => context.formValues.actionType === 'credit',
  },
]
```

```ruby Ruby
form: [
  {
    type: FieldType::ENUM,
    label: 'Action type',
    id: 'actionType',
    enum_values: ['refund', 'replace', 'credit']
  },
  # Refund fields
  {
    type: FieldType::NUMBER,
    label: 'Refund amount',
    if: ->(context) { context.form_values['actionType'] == 'refund' }
  },
  # Replacement fields
  {
    type: FieldType::COLLECTION,
    label: 'Replacement product',
    collection_name: 'products',
    if: ->(context) { context.form_values['actionType'] == 'replace' }
  },
  # Store credit fields
  {
    type: FieldType::NUMBER,
    label: 'Credit amount',
    if: ->(context) { context.form_values['actionType'] == 'credit' }
  }
]
```
</CodeGroup>

### Read-only fields for context

Show record data as read-only context:

<CodeGroup>
```javascript Node.js / Cloud
form: [
  {
    type: 'String',
    label: 'Customer name',
    isReadOnly: true,
    defaultValue: async context => {
      const order = await context.getRecord(['customer:name']);
      return order.customer.name;
    },
  },
  {
    type: 'Number',
    label: 'Refund amount',
    isRequired: true,
  },
]
```

```ruby Ruby
form: [
  {
    type: FieldType::STRING,
    label: 'Customer name',
    is_read_only: true,
    default_value: ->(context) {
      order = context.get_record(['customer:name'])
      order['customer']['name']
    }
  },
  {
    type: FieldType::NUMBER,
    label: 'Refund amount',
    is_required: true
  }
]
```
</CodeGroup>

### Validation with required fields

Combine conditions for complex validation:

<CodeGroup>
```javascript Node.js / Cloud
{
  type: 'String',
  label: 'Manager approval',
  isRequired: context => {
    // Required if amount > 1000 and user is not admin
    return context.formValues.Amount > 1000 &&
           context.caller.role !== 'admin';
  },
}
```

```ruby Ruby
{
  type: FieldType::STRING,
  label: 'Manager approval',
  is_required: ->(context) {
    # Required if amount > 1000 and user is not admin
    context.form_values['Amount'] > 1000 &&
      context.caller.role != 'admin'
  }
}
```
</CodeGroup>

## Accessing form values

In the execute handler, access form values from the context:

<CodeGroup>
```javascript Node.js / Cloud
execute: async (context, resultBuilder) => {
  // Access by label
  const amount = context.formValues.Amount;

  // Access by id (if specified)
  const email = context.formValues['email'];

  // Access with spaces in label
  const firstName = context.formValues['First Name'];

  // Destructure multiple values
  const { Amount, Description } = context.formValues;
}
```

```ruby Ruby
execute: ->(context, result_builder) {
  # Access by label
  amount = context.form_values['Amount']

  # Access by id (if specified)
  email = context.form_values['email']

  # Access with spaces in label
  first_name = context.form_values['First Name']

  # Multiple values
  amount = context.form_values['Amount']
  description = context.form_values['Description']
}
```
</CodeGroup>

## Best practices

<AccordionGroup>
  <Accordion title="Use clear labels" icon="tag">
    Make labels descriptive and action-oriented. Use "Refund amount" instead of "Amount".
  </Accordion>

  <Accordion title="Provide helpful descriptions" icon="circle-info">
    Add descriptions to explain what users should enter, especially for complex fields.
  </Accordion>

  <Accordion title="Set appropriate defaults" icon="sliders">
    Pre-fill forms with sensible defaults to speed up common workflows.
  </Accordion>

  <Accordion title="Use dynamic forms sparingly" icon="wand-magic-sparkles">
    Dynamic forms are powerful but can be confusing. Only use them when truly necessary.
  </Accordion>

  <Accordion title="Validate input" icon="shield-check">
    Use `isRequired` for mandatory fields and add custom validation in the execute handler.
  </Accordion>

  <Accordion title="Choose the right widget" icon="palette">
    Select widgets that match your data type and provide the best user experience.
  </Accordion>
</AccordionGroup>
